// Code generated by sqlc. DO NOT EDIT.
// source: queries.sql

package sqlite

import (
	"context"
	"database/sql"
)

const createConfig = `-- name: CreateConfig :execresult
INSERT INTO configs (
    created_at,
    updated_at,
    server_id
) VALUES (
    datetime('now'),
    datetime('now'),
    $1
)
`

func (q *Queries) CreateConfig(ctx context.Context, serverID string) (sql.Result, error) {
	return q.db.ExecContext(ctx, createConfig, serverID)
}

const createEntity = `-- name: CreateEntity :execresult
INSERT INTO entities (
    created_at,
    updated_at,
    name,
    server_id
) VALUES (
    datetime('now'),
    datetime('now'),
    $1,
    $2
)
`

type CreateEntityParams struct {
	Name     string
	ServerID string
}

func (q *Queries) CreateEntity(ctx context.Context, arg CreateEntityParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createEntity, arg.Name, arg.ServerID)
}

const getBotEntities = `-- name: GetBotEntities :many
SELECT id, created_at, updated_at, name, server_id, karma FROM entities
WHERE server_id = $1 ORDER BY karma ASC LIMIT $2
`

type GetBotEntitiesParams struct {
	ServerID string
	Limit    int32
}

func (q *Queries) GetBotEntities(ctx context.Context, arg GetBotEntitiesParams) ([]Entity, error) {
	rows, err := q.db.QueryContext(ctx, getBotEntities, arg.ServerID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Entity
	for rows.Next() {
		var i Entity
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.ServerID,
			&i.Karma,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConfig = `-- name: GetConfig :one
SELECT id, created_at, updated_at, server_id, no_announce FROM configs WHERE server_id = $1
`

func (q *Queries) GetConfig(ctx context.Context, serverID string) (Config, error) {
	row := q.db.QueryRowContext(ctx, getConfig, serverID)
	var i Config
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ServerID,
		&i.NoAnnounce,
	)
	return i, err
}

const getEntity = `-- name: GetEntity :one
SELECT id, created_at, updated_at, name, server_id, karma FROM entities WHERE server_id = $1 AND name = $2
`

type GetEntityParams struct {
	ServerID string
	Name     string
}

func (q *Queries) GetEntity(ctx context.Context, arg GetEntityParams) (Entity, error) {
	row := q.db.QueryRowContext(ctx, getEntity, arg.ServerID, arg.Name)
	var i Entity
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.ServerID,
		&i.Karma,
	)
	return i, err
}

const getTopEntities = `-- name: GetTopEntities :many
SELECT id, created_at, updated_at, name, server_id, karma FROM entities
WHERE server_id = $1 ORDER BY karma DESC LIMIT $2
`

type GetTopEntitiesParams struct {
	ServerID string
	Limit    int32
}

func (q *Queries) GetTopEntities(ctx context.Context, arg GetTopEntitiesParams) ([]Entity, error) {
	rows, err := q.db.QueryContext(ctx, getTopEntities, arg.ServerID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Entity
	for rows.Next() {
		var i Entity
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.ServerID,
			&i.Karma,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeEntity = `-- name: RemoveEntity :exec
DELETE FROM entities WHERE server_id = $1 AND name = $2
`

type RemoveEntityParams struct {
	ServerID string
	Name     string
}

func (q *Queries) RemoveEntity(ctx context.Context, arg RemoveEntityParams) error {
	_, err := q.db.ExecContext(ctx, removeEntity, arg.ServerID, arg.Name)
	return err
}

const updateConfig = `-- name: UpdateConfig :exec
UPDATE configs SET
    updated_at = datetime('now'),
    no_announce = $1
WHERE server_id = $2
`

type UpdateConfigParams struct {
	NoAnnounce bool
	ServerID   string
}

func (q *Queries) UpdateConfig(ctx context.Context, arg UpdateConfigParams) error {
	_, err := q.db.ExecContext(ctx, updateConfig, arg.NoAnnounce, arg.ServerID)
	return err
}

const updateEntity = `-- name: UpdateEntity :exec
UPDATE entities SET
    updated_at = datetime('now'),
    karma = $3
WHERE server_id = $1 AND name = $2
`

type UpdateEntityParams struct {
	ServerID string
	Name     string
	Karma    int64
}

func (q *Queries) UpdateEntity(ctx context.Context, arg UpdateEntityParams) error {
	_, err := q.db.ExecContext(ctx, updateEntity, arg.ServerID, arg.Name, arg.Karma)
	return err
}
